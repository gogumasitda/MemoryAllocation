# Memory allocator

구조체 생성 및 수정 오버헤드를 줄이기 위한 구조 개선 질문에 답하기 위한 예제 프로젝트다.



아래 인용문은 질문자가 설명한 현재 구조다.

>A 구조체가 어떤 설정을 저장한 구조체라고 보시면 되고,
>B 구조체는 A 구조체 정보를 기반으로 어떤 횟수를 카운팅하는 구조체고 자주 만들어지고 자주 사라집니다.
>그래서 현재 B 구조체를 생성할 때 A 구조체의 일부 정보를 따오고
>추가 정보로 카운팅 데이터를 가지고 있어요.



질문자가 설명한 구조를 아래와 같이 간단히 표현해 보았다.

![class_diagram(as_is)](https://user-images.githubusercontent.com/45933937/159514664-5a57b9d2-492d-4bdb-9497-f19e9fe0529b.png)

>현재 구조가 상호 참조를 안하도록 독립적인 구조체를 생성하고, 
>본래 있던 구조체의 정보를 모두 복사하고 추가 정보를 넣는 상황이에요.
>근데 이게 정보가 점점 많아져서 복사하는 과정에서 오버헤드가 커져서 상당히 많이 느려지더라고요.

현재 구조체 B는 생서시 A의 데이터를 복사해 오고 있다. 
그리고 이 복사 연산 오버헤드가 굉장히 커서 개선이 필요한 상태다.



따라서 간단한 memory pool을 이용하고 매번 복사 연산을 하지 않고 필요한 데이터를 참조하게 함으로써
생성, 수정 오버헤드를 줄이는 두 가지 방법을 소개한다.



첫번째 방법은 memory pool만을 이용한 방법으로 구현이 매우 간단하나 두번째 방법에 비해서 메모리 낭비가 심하다. 특히나 setting_values의 크기가 A의 object별로 다르며 그 분포가 최소값에 몰려있을 수록 낭비가 심해진다.

두번째 방법은 setting_values를 압축하여 메모리 낭비를 줄이는 방법이다. 첫번째 방법에 비해서 구현이 어렵다. 따라서 setting_values의 범위가 최대값에 몰려있다면 첫번째 방법을 선택하는 것이 옳다.

# Requirements

질문을 정리하여 요구사항을 아래와 같이 6가지로 정리해 보았다.

>개발 표준이 C라 개인적으로 c++로 개발하고 싶어도 못하는 상황이네요.

1. c언어로 개발을 진행해야 됨.



>그런데 B구조체를 만들때 A구조체의 정보를 꽤 많이 복사하기 때문에 생성시 오버헤드가 크다는 것이 문제고

2. B 생성시 A의 데이터를 복사하면서 발생하는 오버헤드를 줄여야 함.



>A구조체는 설정을 저장하고 있기 때문에 사용자에 의해 바뀔수도, 삭제될 수도 있는 상태에요

3. A는 유저에 의해서 수정, 삭제가 자유로우며 이로인해 발생하는 오버헤드 역시 적어야 함.



>오버헤드를 줄이기 위해 참조하려는 구조로 바꾸려는건데 A구조체가 삭제되었을 경우 참조에 오류가 생길거라..

4. A의 object가 삭제돼도 이를 참조한 B object들의 연산에 지장이 없어야 함.



>A는 사용자 설정에 따라 다른데.. 몇백개까진 가능할거에요.
>
>B는 만 개 이상까지도 가능할 것 같은데, 정확하겐 확인해봐야 알 것 같네요

5. 동시에 존재하는 A의 최대 개수는 대략 100개, B의 개수는 100 * 10000으로 가정함.
6. A의 setting values는 64kb,  B의 count_data는 8byte를 가정함.

# How it works

## Memory pool

기본적인 구조는 아래와 같다.

![image](https://user-images.githubusercontent.com/45933937/160633836-472a4969-2a50-45f2-8d03-42afceb0c13a.png)

- B는 더이상 setting values를 직접 가지지 않는다. setting values는 오직 A가 가진다.
  - 이를 통해서 새로운 B object를 만들 때마다 A의 데이터를 B로 복사하는데 드는 오버헤드를 없앨 수 있다.
  - 또한, 기존 구조에서 가장 큰 문제는 A의 데이터가 수정될 경우, 전체 B를 탐색하면서 데이터를 모두 고쳐야 했다. 하지만 이 구조를 유지할 경우 A의 수정은 A object 1번만 하면된다.
- A를 미리 사용할만큼 메모리에 할당한 뒤, 이를 Stack에서 관리한다.
  Stack은 새로운 A object가 생성될 때, memory pool에서 사용 가능한 A를 반환한다.
  그리고 A object가 종료되었을 때, 해당 A의 index를 다시 Stack 담아 재사용할 준비를 한다.
- A의 관리는 is_alive와 reference_cnt로 진행한다.
  - 사용자가 A object를 죽였을 경우, is_alive를 false로 바꿔 표시한다.
    다만, object의 is_alive가 false로 바뀌었어도 object가 실제 죽는 것은 아니다.
  - reference cnt는 현재 해당 object를 참조하고 있는 B object의 숫자를 의미한다.
    reference cnt도 0이 되어야만 A는 실제 종료된 것이고 해당 object를 다시 stack으로 반환한다.
- 그렇다면 Stack과 A의 memory pool 크기는 몇이 돼야 하는가?
  - 본인이 실제 시스템을 돌려보면서 데이터 분포를 분석해보고 적절한 크기를 설정해야 한다.
    1. 처음 질문에서 A가 동시에 최대 존재할 수 있는 개수로 100개 가량을 뽑았지만 이는 정확하지 않다.
    2. 현재 구조에선 사용자가 A를 종료했더라도 해당 A가 바로 memory pool로 반환되지 않는다.
       참조하고 있는 모든 B가 종료되어야 반환되는 구조다. 
       그렇다면 사실 memory pool과 Stack의 최대 사이즈는 **실제 살아있는 A + 종료됐으나 아직 참조되고 있는 A**가 될 것이다.
       따라서 정확한 숫자는 시스템을 운영하며 데이터를 분석해서 최악의 경우를 커버할 수 있는 수자로 설정해야 한다.



main.c 파일로 테스트가 가능하다.



하지만 memory pool만을 이용한 방식은 메모리 낭비가 심하다는 단점이 있다.

1. 만약 A가 가지는 setting value의 크기가 object마다 다르고
2. 그 분포가 최소 사이즈에 집중되어 있다면

현재 구조는 정말 많은 메모리를 낭비하게 된다.



이 문제를 해결하기 위해서 A의 setting value 크기를 가변적으로 바꿔보겠다.

가장 쉬운 방법은 동적 할당을 하는 것이다.
A를 생성, 삭제하는 과정에서 runtime 속도를 희생해도 된다고 한다면
setting values를 포인터로 바꿔 A가 생성될 때마다 setting values를 동적으로 할당해 주면 된다.
포인터의 크기는 각 32/64 bit 운영체제 기준으로 각가 4, 8byte이므로 데이터 크기와 포인터 사이즈를 비교해서 선택하면 된다.

## Memory pool + bit compression

하지만 동적 할당은 너무 느리다.
