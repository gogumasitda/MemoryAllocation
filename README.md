[TOC]

# Memory allocator

구조체 생성 및 수정 오버헤드를 줄이기 위한 구조 개선 질문에 답하기 위한 예제 프로젝트다.



아래 인용문은 질문자가 설명한 현재 구조다.

>A 구조체가 어떤 설정을 저장한 구조체라고 보시면 되고,
>B 구조체는 A 구조체 정보를 기반으로 어떤 횟수를 카운팅하는 구조체고 자주 만들어지고 자주 사라집니다.
>그래서 현재 B 구조체를 생성할 때 A 구조체의 일부 정보를 따오고
>추가 정보로 카운팅 데이터를 가지고 있어요.



질문자가 설명한 구조를 아래와 같이 간단히 표현해 보았다.

![class_diagram(as_is)](https://user-images.githubusercontent.com/45933937/159514664-5a57b9d2-492d-4bdb-9497-f19e9fe0529b.png)

>현재 구조가 상호 참조를 안하도록 독립적인 구조체를 생성하고, 
>본래 있던 구조체의 정보를 모두 복사하고 추가 정보를 넣는 상황이에요.
>근데 이게 정보가 점점 많아져서 복사하는 과정에서 오버헤드가 커져서 상당히 많이 느려지더라고요.

현재 구조체 B는 생서시 A의 데이터를 복사해 오고 있다. 
그리고 이 복사 연산 오버헤드가 굉장히 커서 개선이 필요한 상태다.



따라서 간단한 memory pool을 이용하고 매번 복사 연산을 하지 않고 필요한 데이터를 참조하게 함으로써
생성, 수정 오버헤드를 줄이는 두 가지 방법을 소개한다.



첫번째 방법은 memory pool만을 이용한 방법으로 구현이 매우 간단하나 두번째 방법에 비해서 메모리 낭비가 심하다. 특히나 setting_values의 크기가 A의 object별로 다르며 그 분포가 최소값에 몰려있을 수록 낭비가 심해진다.

두번째 방법은 setting_values를 압축하여 메모리 낭비를 줄이는 방법이다. 첫번째 방법에 비해서 구현이 어렵다. 따라서 setting_values의 범위가 최대값에 몰려있다면 첫번째 방법을 선택하는 것이 옳다.

# Requirements

질문을 정리하여 요구사항을 아래와 같이 6가지로 정리해 보았다.

>개발 표준이 C라 개인적으로 c++로 개발하고 싶어도 못하는 상황이네요.

1. c언어로 개발을 진행해야 됨.



>그런데 B구조체를 만들때 A구조체의 정보를 꽤 많이 복사하기 때문에 생성시 오버헤드가 크다는 것이 문제고

2. B 생성시 A의 데이터를 복사하면서 발생하는 오버헤드를 줄여야 함.



>A구조체는 설정을 저장하고 있기 때문에 사용자에 의해 바뀔수도, 삭제될 수도 있는 상태에요
>

3. A는 유저에 의해서 수정, 삭제가 자유로우며 이로인해 발생하는 오버헤드 역시 적어야 함.



>오버헤드를 줄이기 위해 참조하려는 구조로 바꾸려는건데 A구조체가 삭제되었을 경우 참조에 오류가 생길거라..

4. A의 object가 삭제돼도 이를 참조한 B object들의 연산에 지장이 없어야 함.



>A는 사용자 설정에 따라 다른데.. 몇백개까진 가능할거에요.
>
>B는 만 개 이상까지도 가능할 것 같은데, 정확하겐 확인해봐야 알 것 같네요

5. 동시에 존재하는 A의 최대 개수는 대략 100개, B의 개수는 100 * 10000으로 가정함.
6. A의 setting values는 64kb,  B의 count_data는 8byte를 가정함.